'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = typeof document !== 'undefined';

var Cxs = function Cxs() {
  var _this = this;

  this.cache = {};
  this.sheet = createSheet();
  this.count = 0;
  this.rules = [];

  var createCssRule = function createCssRule(className, key, value, media, pseudo) {
    var rule = '.' + className + pseudo + '{' + key + ':' + value + '}';
    if (!media) return rule;
    return media + '{' + rule + '}';
  };

  var insert = function insert(rule) {
    _this.sheet.insertRule(rule, _this.count);
  };

  var createStyle = function createStyle(key, value) {
    var media = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    var pseudo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

    var className = alphaHash(_this.count);
    _this.count++;

    var rule = createCssRule(className, key, value, media, pseudo);
    // this.rules.push(rule)
    insert(rule);

    return className;

    /*
    const id = key + value + media + pseudo
    const dupe = this.cache[id]
     if (dupe) return dupe
     const className = alphaHash(this.count)
    this.count++
    const selector = '.' + className + pseudo
    // To do
    // const prop = hyphenate(key)
    // const val = addPx(key, value)
    const rule = selector + '{' + key + ':' + value + '}'
    const css = media ? media + '{' + rule + '}' : rule
    this.sheet.insertRule(css, this.sheet.cssRules.length)
    this.cache[id] = className
     return className
    */
  };

  var parse = function parse(styles, media) {
    var pseudo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

    var className = '';

    for (var key in styles) {
      var value = styles[key];
      var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);

      if (type === 'string' || type === 'number') {
        className += ' ' + createStyle(key, value, media, pseudo);
        continue;
      }

      /*
      const firstChar = key.charAt(0)
      if (firstChar === ':') {
      className += ' ' + parse(value, media, pseudo + key)
      continue
      }
      if (firstChar === '@') {
      className += ' ' + parse(value, key, pseudo)
      continue
      }
      continue
      */
    }

    return className.trim();
  };

  var cxs = function cxs(styles) {
    return parse(styles);
  };

  cxs.getCss = function () {
    var css = '';
    return _this.rules.join('');
    /*
    const rules = this.sheet.cssRules
    for (let i = 0; i < rules.length; i++) {
    css += rules[i].cssText
    }
    return css
    */
  };

  return cxs;
};

function createSheet() {
  if (!isBrowser) {
    var _ret = function () {
      var sheet = {
        cssRules: []
      };
      sheet.insertRule = function (rule) {
        // const cssRule = { cssText: rule }
        sheet.cssRules.push(rule);
        // sheet.cssRules.push({
        //   cssText: rule
        // })
      };
      return {
        v: sheet
      };
    }();

    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
  } else {
    var tag = document.createElement('style');
    document.head.appendChild(tag);
    return tag.sheet;
  }
}

var alphaHash = function alphaHash(n) {
  if (alpha[n]) return alpha[n];

  var residual = Math.floor(n);
  var result = '';
  var length = alpha.length;

  while (residual !== 0) {
    var i = residual % length;
    result = alpha[i] + result;
    residual = Math.floor(residual / length);
  }

  return result;
};

var alpha = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');

module.exports = Cxs;